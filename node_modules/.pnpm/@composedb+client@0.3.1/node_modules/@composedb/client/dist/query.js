export function toBaseQuery(source) {
    const query = {
        model: source.model
    };
    if (source.account != null) {
        query.account = source.account;
    }
    if (source.filter != null) {
        query.filter = source.filter;
    }
    return query;
}
export function toPaginationQuery(source) {
    const { after , before , first , last , ...base } = source;
    let pagination;
    if (first != null) {
        pagination = {
            first
        };
        if (after != null) {
            pagination.after = after;
        }
    } else if (last != null) {
        pagination = {
            last
        };
        if (before != null) {
            pagination.before = before;
        }
    }
    if (pagination == null) {
        throw new Error('Missing "first" or "last" connection argument');
    }
    return {
        ...toBaseQuery(base),
        ...pagination
    };
}
export function toRelayConnection(ceramic, page) {
    return {
        edges: (page.edges ?? []).map(({ cursor , node  })=>{
            return {
                cursor,
                node: node ? ceramic.buildStreamFromState(node) : null
            };
        }),
        pageInfo: {
            ...page.pageInfo,
            startCursor: page.pageInfo.startCursor ?? null,
            endCursor: page.pageInfo.endCursor ?? null
        }
    };
}
export async function queryConnection(ceramic, query) {
    const indexQuery = toPaginationQuery(query);
    const page = await ceramic.index.query(indexQuery);
    return toRelayConnection(ceramic, page);
}
export async function querySingle(ceramic, query) {
    const indexQuery = {
        ...toBaseQuery(query),
        last: 1
    };
    const result = await ceramic.index.query(indexQuery);
    const node = result.edges?.[0]?.node;
    return node ? ceramic.buildStreamFromState(node) : null;
}
