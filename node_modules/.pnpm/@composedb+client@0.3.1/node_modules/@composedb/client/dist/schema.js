function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { CeramicCommitID, getScalar } from '@composedb/graphql-scalars';
import { GraphQLBoolean, GraphQLEnumType, GraphQLID, GraphQLInputObjectType, GraphQLInt, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLSchema, assertValidSchema } from 'graphql';
import { connectionArgs, connectionDefinitions, mutationWithClientMutationId, nodeDefinitions } from 'graphql-relay';
const connectionArgsWithAccount = {
    ...connectionArgs,
    account: {
        type: GraphQLID,
        description: 'Returns only documents created by the provided account'
    }
};
const UpdateOptionsInput = new GraphQLInputObjectType({
    name: 'UpdateOptionsInput',
    fields: {
        replace: {
            type: GraphQLBoolean,
            defaultValue: false,
            description: 'Fully replace the document contents instead of performing a shallow merge'
        },
        version: {
            type: CeramicCommitID,
            description: 'Only perform mutation if the document matches the provided version'
        }
    }
});
var // Source composite
_def = /*#__PURE__*/ new WeakMap(), // Schema options
_isReadonly = /*#__PURE__*/ new WeakMap(), // Internal records
_types = /*#__PURE__*/ new WeakMap(), _inputObjects = /*#__PURE__*/ new WeakMap(), _mutations = /*#__PURE__*/ new WeakMap(), // Internal mapping of model IDs to object names
_modelAliases = /*#__PURE__*/ new WeakMap();
class SchemaBuilder {
    build() {
        this._buildEnums();
        const definitions = this._createSharedDefinitions();
        this._buildObjects(definitions);
        this._buildConnections();
        const schema = this._createSchema(definitions);
        assertValidSchema(schema);
        return schema;
    }
    _createSharedDefinitions() {
        const nodeDefs = nodeDefinitions(async (id, ctx)=>{
            return id.startsWith('did:') ? id : await ctx.loadDoc(id);
        }, (didOrDoc)=>{
            return typeof didOrDoc === 'string' ? 'CeramicAccount' : _classPrivateFieldGet(this, _modelAliases)[didOrDoc.metadata.model?.toString()];
        });
        const accountObject = new GraphQLObjectType({
            name: 'CeramicAccount',
            interfaces: [
                nodeDefs.nodeInterface
            ],
            fields: ()=>{
                const config = {
                    id: {
                        type: new GraphQLNonNull(GraphQLID),
                        description: 'Globally unique identifier of the account (DID string)',
                        resolve: (did)=>did
                    },
                    isViewer: {
                        type: new GraphQLNonNull(GraphQLBoolean),
                        description: 'Whether the Ceramic instance is currently authenticated with this account or not',
                        resolve: (did, _, ctx)=>ctx.authenticated && ctx.viewerID === did
                    }
                };
                for (const [alias, reference] of Object.entries(_classPrivateFieldGet(this, _def).accountData ?? {})){
                    const model = _classPrivateFieldGet(this, _def).models[reference.name];
                    if (model == null) {
                        throw new Error(`Missing model for reference name: ${reference.name}`);
                    }
                    if (reference.type === 'node') {
                        config[alias] = {
                            type: _classPrivateFieldGet(this, _types)[reference.name],
                            resolve: async (account, _, ctx)=>{
                                return await ctx.querySingle({
                                    account,
                                    model: model.id
                                });
                            }
                        };
                    } else if (reference.type === 'connection') {
                        config[alias] = {
                            type: _classPrivateFieldGet(this, _types)[`${reference.name}Connection`],
                            args: connectionArgs,
                            resolve: async (account, args, ctx)=>{
                                return await ctx.queryConnection({
                                    ...args,
                                    account,
                                    model: model.id
                                });
                            }
                        };
                    } else {
                        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                        throw new Error(`Unsupported reference type: ${reference.type}`);
                    }
                }
                return config;
            }
        });
        const queryFields = {
            node: nodeDefs.nodeField,
            viewer: {
                type: accountObject,
                description: 'Account currently authenticated on the Ceramic instance, if set',
                resolve: (_self, _args, ctx)=>ctx.viewerID
            }
        };
        return {
            ...nodeDefs,
            accountObject,
            queryFields
        };
    }
    _buildEnums() {
        for (const [name, values] of Object.entries(_classPrivateFieldGet(this, _def).enums)){
            _classPrivateFieldGet(this, _types)[name] = new GraphQLEnumType({
                name,
                values: values.reduce((acc, value)=>{
                    acc[value] = {
                        value
                    };
                    return acc;
                }, {})
            });
        }
    }
    _buildObjects(definitions) {
        for (const [name, fields] of Object.entries(_classPrivateFieldGet(this, _def).objects)){
            this._buildObjectType({
                definitions,
                name,
                fields
            });
        }
    }
    _buildObjectType(params) {
        const model = _classPrivateFieldGet(this, _def).models[params.name];
        return model ? this._buildDocumentObjectType({
            model,
            ...params
        }) : this._buildEmbeddedObjectType(params);
    }
    _buildDocumentObjectType({ model , definitions , name , fields  }) {
        _classPrivateFieldGet(this, _types)[name] = new GraphQLObjectType({
            name,
            interfaces: [
                definitions.nodeInterface
            ],
            isTypeOf: (value)=>{
                return value.metadata.model.toString() === model.id;
            },
            fields: ()=>{
                const config = {
                    id: {
                        // Use GraphQLID here for Relay compliance
                        type: new GraphQLNonNull(GraphQLID),
                        resolve: (doc)=>doc.id.toString()
                    }
                };
                for (const [key, field] of Object.entries(fields)){
                    switch(field.type){
                        case 'meta':
                            continue;
                        case 'reference':
                            config[key] = this._buildDocumentObjectReferenceField(key, field);
                            break;
                        case 'list':
                            config[key] = {
                                type: this._buildObjectListFieldType(definitions, field),
                                resolve: (doc)=>doc.content?.[key]
                            };
                            break;
                        case 'view':
                            config[key] = this._buildDocumentObjectViewField(key, definitions, field, fields);
                            break;
                        default:
                            config[key] = {
                                type: this._buildScalarFieldType(definitions, field),
                                resolve: (doc)=>doc.content?.[key]
                            };
                    }
                }
                return config;
            }
        });
        if (!_classPrivateFieldGet(this, _isReadonly)) {
            this._buildInputObjectType(name, fields);
            this._buildNodeMutations(definitions.queryFields, name, model);
        }
    }
    _buildEmbeddedObjectType({ definitions , name , fields  }) {
        _classPrivateFieldGet(this, _types)[name] = new GraphQLObjectType({
            name,
            fields: ()=>{
                const config = {};
                for (const [key, field] of Object.entries(fields)){
                    switch(field.type){
                        case 'meta':
                            continue;
                        case 'reference':
                            config[key] = this._buildEmbeddedObjectReferenceField(key, field);
                            break;
                        case 'list':
                            config[key] = {
                                type: this._buildObjectListFieldType(definitions, field),
                                resolve: (obj)=>obj[key]
                            };
                            break;
                        case 'view':
                            throw new Error(`Unsupported view field ${key} on embedded object ${name}`);
                        default:
                            config[key] = {
                                type: this._buildScalarFieldType(definitions, field),
                                resolve: (obj)=>obj[key]
                            };
                    }
                }
                return config;
            }
        });
        if (!_classPrivateFieldGet(this, _isReadonly)) {
            this._buildInputObjectType(name, fields);
        }
    }
    _buildConnections() {
        for (const objectName of Object.keys(_classPrivateFieldGet(this, _def).models)){
            const nodeType = _classPrivateFieldGet(this, _types)[objectName];
            if (nodeType == null) {
                throw new Error(`Missing object type for connection: ${objectName}`);
            }
            const { connectionType , edgeType  } = connectionDefinitions({
                nodeType
            });
            _classPrivateFieldGet(this, _types)[`${objectName}Connection`] = connectionType;
            _classPrivateFieldGet(this, _types)[`${objectName}Edge`] = edgeType;
        }
    }
    _buildDocumentObjectReferenceField(key, field) {
        const name = field.refType === 'connection' ? field.refName + 'Connection' : field.refName;
        const ref = _classPrivateFieldGet(this, _types)[name];
        if (ref == null) {
            throw new Error(`Missing type: ${name}`);
        }
        const type = field.required ? new GraphQLNonNull(ref) : ref;
        switch(field.refType){
            case 'connection':
                return {
                    type,
                    args: connectionArgs,
                    resolve: (_doc, _args, _ctx)=>{
                        throw new Error('Not implemented');
                    }
                };
            case 'node':
                return {
                    type,
                    args: connectionArgs,
                    resolve: async (doc, _, ctx)=>{
                        return await ctx.loadDoc(doc.content[key]);
                    }
                };
            case 'enum':
            case 'object':
                return {
                    type,
                    resolve: (doc)=>doc.content[key]
                };
            default:
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Unsupported reference type on document object: ${field.refType}`);
        }
    }
    _buildEmbeddedObjectReferenceField(key, field) {
        const ref = _classPrivateFieldGet(this, _types)[field.refName];
        if (ref == null) {
            throw new Error(`Missing type: ${field.refName}`);
        }
        const type = field.required ? new GraphQLNonNull(ref) : ref;
        switch(field.refType){
            case 'enum':
            case 'object':
                return {
                    type,
                    resolve: (obj)=>obj[key]
                };
            default:
                throw new Error(`Unsupported reference type on embedded object: ${field.refType}`);
        }
    }
    _buildObjectListFieldType(definitions, field) {
        let itemType;
        if (field.item.type === 'reference') {
            itemType = _classPrivateFieldGet(this, _types)[field.item.refName];
            if (itemType == null) {
                throw new Error(`Missing referenced object type: ${field.item.refName}`);
            }
        } else if (field.item.type === 'did') {
            itemType = definitions.accountObject;
        } else {
            itemType = getScalar(field.item.type);
        }
        if (field.item.required) {
            itemType = new GraphQLNonNull(itemType);
        }
        const type = new GraphQLList(itemType);
        return field.required ? new GraphQLNonNull(type) : type;
    }
    _buildDocumentObjectRelation(key, relation, objectFields) {
        const modelAlias = _classPrivateFieldGet(this, _modelAliases)[relation.model];
        if (modelAlias == null) {
            throw new Error(`Model alias not found for relation with ID ${relation.model} on field ${key}`);
        }
        switch(relation.source){
            case 'document':
                {
                    const ref = objectFields[relation.property];
                    if (ref == null) {
                        throw new Error(`Missing reference field ${relation.property} for relation defined on field ${key}`);
                    }
                    return {
                        type: _classPrivateFieldGet(this, _types)[modelAlias],
                        resolve: async (doc, _args, ctx)=>{
                            const id = doc.content?.[relation.property];
                            if (id == null) {
                                return null;
                            }
                            const loaded = await ctx.loadDoc(id);
                            if (loaded == null) {
                                return null;
                            }
                            const loadedModel = loaded.metadata.model.toString();
                            if (relation.model != null && loadedModel !== relation.model) {
                                console.warn(`Ignoring unexpected model ${loadedModel} for document ${id}, expected model ${relation.model}`);
                                return null;
                            }
                            return loaded;
                        }
                    };
                }
            case 'queryConnection':
                return {
                    type: new GraphQLNonNull(_classPrivateFieldGet(this, _types)[`${modelAlias}Connection`]),
                    args: connectionArgsWithAccount,
                    resolve: async (doc, args, ctx)=>{
                        const account = args.account === 'documentAccount' ? doc.metadata.controller : args.account;
                        return await ctx.queryConnection({
                            ...args,
                            account,
                            model: relation.model,
                            filter: {
                                [relation.property]: doc.id.toString()
                            }
                        });
                    }
                };
            case 'queryCount':
                return {
                    type: new GraphQLNonNull(GraphQLInt),
                    args: {
                        account: {
                            type: GraphQLID,
                            description: 'Counts only documents created by the provided account'
                        }
                    },
                    resolve: async (doc, args, ctx)=>{
                        const account = args.account === 'documentAccount' ? doc.metadata.controller : args.account;
                        return await ctx.queryCount({
                            account,
                            model: relation.model,
                            filter: {
                                [relation.property]: doc.id.toString()
                            }
                        });
                    }
                };
            default:
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Unsupported relation source: ${relation.source}`);
        }
    }
    _buildDocumentObjectViewField(key, definitions, field, objectFields) {
        switch(field.viewType){
            case 'documentAccount':
                return {
                    type: new GraphQLNonNull(definitions.accountObject),
                    description: 'Account controlling the document',
                    resolve: (doc)=>doc.metadata.controller
                };
            case 'documentVersion':
                return {
                    type: new GraphQLNonNull(CeramicCommitID),
                    description: 'Current version of the document',
                    resolve: (doc)=>doc.commitId.toString()
                };
            case 'relation':
                return this._buildDocumentObjectRelation(key, field.relation, objectFields);
            default:
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Unsupported view type: ${field.viewType}`);
        }
    }
    _buildScalarFieldType(definitions, field) {
        const type = field.type === 'did' ? definitions.accountObject : getScalar(field.type);
        return field.required ? new GraphQLNonNull(type) : type;
    }
    _buildInputObjectType(name, fields) {
        const isDocument = _classPrivateFieldGet(this, _def).models[name] != null;
        const buildFields = (required)=>{
            const config = {};
            const inputPrefix = isDocument || required ? '' : 'Partial';
            for (const [key, field] of Object.entries(fields)){
                let type;
                switch(field.type){
                    case 'meta':
                    case 'view':
                        continue;
                    case 'reference':
                        switch(field.refType){
                            case 'connection':
                                continue;
                            case 'enum':
                                type = _classPrivateFieldGet(this, _types)[field.refName];
                                break;
                            case 'node':
                                type = GraphQLID;
                                break;
                            case 'object':
                                {
                                    type = _classPrivateFieldGet(this, _inputObjects)[inputPrefix + field.refName];
                                    if (type == null) {
                                        throw new Error(`Missing referenced input type: ${inputPrefix + field.refName}`);
                                    }
                                    break;
                                }
                        }
                        break;
                    case 'list':
                        {
                            let itemType;
                            if (field.item.type === 'reference') {
                                itemType = _classPrivateFieldGet(this, _inputObjects)[inputPrefix + field.item.refName];
                                if (itemType == null) {
                                    throw new Error(`Missing referenced input type: ${inputPrefix + field.item.refName}`);
                                }
                            } else {
                                itemType = getScalar(field.item.type);
                            }
                            type = new GraphQLList(itemType);
                            break;
                        }
                    default:
                        type = getScalar(field.type);
                }
                if (type != null) {
                    config[key] = {
                        type: required && field.required ? new GraphQLNonNull(type) : type
                    };
                }
            }
            return config;
        };
        _classPrivateFieldGet(this, _inputObjects)[name] = new GraphQLInputObjectType({
            name: `${name}Input`,
            fields: ()=>buildFields(true)
        });
        if (isDocument) {
            _classPrivateFieldGet(this, _inputObjects)[`Partial${name}`] = new GraphQLInputObjectType({
                name: `Partial${name}Input`,
                fields: ()=>buildFields(false)
            });
        }
    }
    _buildNodeMutations(queryFields, name, model) {
        _classPrivateFieldGet(this, _mutations)[`create${name}`] = mutationWithClientMutationId({
            name: `Create${name}`,
            inputFields: ()=>({
                    content: {
                        type: new GraphQLNonNull(_classPrivateFieldGet(this, _inputObjects)[name])
                    }
                }),
            outputFields: ()=>({
                    ...queryFields,
                    document: {
                        type: new GraphQLNonNull(_classPrivateFieldGet(this, _types)[name])
                    }
                }),
            mutateAndGetPayload: async (input, ctx)=>{
                if (ctx.ceramic.did == null || !ctx.ceramic.did.authenticated) {
                    throw new Error('Ceramic instance is not authenticated');
                }
                const document = model.accountRelation.type === 'single' ? await ctx.createSingle(model.id, input.content) : await ctx.createDoc(model.id, input.content);
                return {
                    document
                };
            }
        });
        _classPrivateFieldGet(this, _mutations)[`update${name}`] = mutationWithClientMutationId({
            name: `Update${name}`,
            inputFields: ()=>({
                    id: {
                        type: new GraphQLNonNull(GraphQLID)
                    },
                    content: {
                        type: new GraphQLNonNull(_classPrivateFieldGet(this, _inputObjects)[`Partial${name}`])
                    },
                    options: {
                        type: UpdateOptionsInput
                    }
                }),
            outputFields: ()=>({
                    ...queryFields,
                    document: {
                        type: new GraphQLNonNull(_classPrivateFieldGet(this, _types)[name])
                    }
                }),
            mutateAndGetPayload: async (input, ctx)=>{
                if (ctx.ceramic.did == null || !ctx.ceramic.did.authenticated) {
                    throw new Error('Ceramic instance is not authenticated');
                }
                return {
                    document: await ctx.updateDoc(input.id, input.content, input.options)
                };
            }
        });
    }
    _createSchema(definitions) {
        const queryFields = {
            ...definitions.queryFields
        };
        for (const [alias, model] of Object.entries(_classPrivateFieldGet(this, _def).models)){
            const first = alias[0].toLowerCase();
            const rest = alias.slice(1);
            queryFields[`${first}${rest}Index`] = {
                type: _classPrivateFieldGet(this, _types)[`${alias}Connection`],
                args: connectionArgs,
                resolve: async (_, args, ctx)=>{
                    return await ctx.queryConnection({
                        ...args,
                        model: model.id
                    });
                }
            };
        }
        const schemaFields = {
            query: new GraphQLObjectType({
                name: 'Query',
                fields: queryFields
            })
        };
        if (!_classPrivateFieldGet(this, _isReadonly) && Object.keys(_classPrivateFieldGet(this, _mutations)).length !== 0) {
            schemaFields.mutation = new GraphQLObjectType({
                name: 'Mutation',
                fields: _classPrivateFieldGet(this, _mutations)
            });
        }
        return new GraphQLSchema(schemaFields);
    }
    constructor(params){
        _classPrivateFieldInit(this, _def, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _isReadonly, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _types, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInit(this, _inputObjects, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInit(this, _mutations, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInit(this, _modelAliases, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldSet(this, _def, params.definition);
        _classPrivateFieldSet(this, _isReadonly, !!params.readonly);
        _classPrivateFieldSet(this, _modelAliases, Object.entries(_classPrivateFieldGet(this, _def).models).reduce((aliases, [alias, model])=>{
            aliases[model.id] = alias;
            return aliases;
        }, {}));
    }
}
/**
 * Create a GraphQL schema from a runtime composite definition
 */ export function createGraphQLSchema(params) {
    return new SchemaBuilder(params).build();
}
