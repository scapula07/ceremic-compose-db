function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { queryConnection, querySingle, toBaseQuery } from './query.js';
import { DocumentLoader } from './loader.js';
var _ceramic = /*#__PURE__*/ new WeakMap(), _loader = /*#__PURE__*/ new WeakMap();
/**
 * GraphQL execution context, exported by the {@linkcode client} module.
 *
 * ```sh
 * import { Context } from '@composedb/client'
 * ```
 */ export class Context {
    /**
   * Returns whether the Ceramic client instance used internally is authenticated or not. When not
   * authenticated, mutations will fail.
   */ get authenticated() {
        return _classPrivateFieldGet(this, _ceramic).did?.authenticated ?? false;
    }
    /**
   * Ceramic client instance used internally.
   */ get ceramic() {
        return _classPrivateFieldGet(this, _ceramic);
    }
    /**
   * Document loader instance used internally.
   */ get loader() {
        return _classPrivateFieldGet(this, _loader);
    }
    /**
   * ID of the current viewer (authenticated DID), if set.
   */ get viewerID() {
        const did = _classPrivateFieldGet(this, _ceramic).did;
        return did?.hasParent ? did.parent : did?.id ?? null;
    }
    /**
   * Load a document by ID, using the cache if possible.
   */ async loadDoc(id, fresh = false) {
        if (fresh) {
            _classPrivateFieldGet(this, _loader).clear(id);
        }
        return await _classPrivateFieldGet(this, _loader).load(id);
    }
    /**
   * Create a new document with the given model and content.
   */ async createDoc(model, content) {
        return await _classPrivateFieldGet(this, _loader).create(model, content);
    }
    /**
   * Create a new single document with the given model and content.
   */ async createSingle(model, content) {
        const controller = this.viewerID;
        if (controller == null) {
            throw new Error('Document can only be created with an authenticated account');
        }
        const doc = await _classPrivateFieldGet(this, _loader).single(controller, model);
        await doc.replace(content);
        return doc;
    }
    /**
   * Update an existing document.
   */ async updateDoc(id, content, options) {
        return await _classPrivateFieldGet(this, _loader).update(id, content, options);
    }
    /**
   * Query the index for a connection of documents.
   */ async queryConnection(query) {
        return await queryConnection(_classPrivateFieldGet(this, _ceramic), query);
    }
    /**
   * Query the index for the total number of documents matching the query parameters.
   */ async queryCount(query) {
        return await _classPrivateFieldGet(this, _ceramic).index.count(toBaseQuery(query));
    }
    /**
   * Query the index for a single document.
   */ async querySingle(query) {
        return await querySingle(_classPrivateFieldGet(this, _ceramic), query);
    }
    constructor(params){
        _classPrivateFieldInit(this, _ceramic, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _loader, {
            writable: true,
            value: void 0
        });
        const { cache , ceramic  } = params;
        _classPrivateFieldSet(this, _ceramic, ceramic);
        _classPrivateFieldSet(this, _loader, params.loader ?? new DocumentLoader({
            ceramic,
            cache
        }));
    }
}
