function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { ModelInstanceDocument } from '@ceramicnetwork/stream-model-instance';
import { StreamID, StreamRef } from '@ceramicnetwork/streamid';
import DataLoader from 'dataloader';
/** @internal */ export function idToString(id) {
    return typeof id === 'string' ? StreamRef.from(id).toString() : id.toString();
}
const tempBatchLoadFn = ()=>Promise.resolve([]);
var _ceramic = /*#__PURE__*/ new WeakMap(), _useCache = /*#__PURE__*/ new WeakMap();
export class DocumentLoader extends DataLoader {
    /**
   * Add a ModelInstanceDocument to the local cache, if enabled.
   */ cache(stream) {
        if (!_classPrivateFieldGet(this, _useCache)) {
            return false;
        }
        const id = stream.id.toString();
        this.clear(id).prime(id, stream);
        return true;
    }
    /**
   * Create a new ModelInstanceDocument and add it to the cache, if enabled.
   */ async create(model, content, { controller , ...options } = {}) {
        const metadata = {
            controller,
            model: model instanceof StreamID ? model : StreamID.fromString(model)
        };
        const stream = await ModelInstanceDocument.create(_classPrivateFieldGet(this, _ceramic), content, metadata, options);
        this.cache(stream);
        return stream;
    }
    /**
   * Load a ModelInstanceDocument from the cache (if enabled) or remotely.
   */ async load(id) {
        return await super.load(id);
    }
    /**
   * Create or load a deterministic ModelInstanceDocument and cache it.
   */ async single(controller, model, options) {
        const metadata = {
            controller,
            model: model instanceof StreamID ? model : StreamID.fromString(model)
        };
        const stream = await ModelInstanceDocument.single(_classPrivateFieldGet(this, _ceramic), metadata, options);
        this.cache(stream);
        return stream;
    }
    /**
   * Update a ModelInstanceDocument after loading the stream remotely, bypassing the cache.
   */ async update(streamID, content, { replace , version , ...options } = {}) {
        const id = idToString(streamID);
        this.clear(id);
        const stream = await this.load(id);
        if (version != null && stream.commitId.toString() !== version) {
            throw new Error('Stream version mismatch');
        }
        const newContent = replace ? content : {
            ...stream.content,
            ...content
        };
        await stream.replace(newContent, options);
        return stream;
    }
    constructor(params){
        super(tempBatchLoadFn, {
            cache: true,
            cacheKeyFn: idToString,
            cacheMap: params.cache != null && typeof params.cache !== 'boolean' ? params.cache : undefined
        });
        _classPrivateFieldInit(this, _ceramic, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _useCache, {
            writable: true,
            value: void 0
        });
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore internal method
        this._batchLoadFn = async (keys)=>{
            if (!params.cache) {
                // Disable cache but keep batching behavior - from https://github.com/graphql/dataloader#disabling-cache
                this.clearAll();
            }
            const results = await params.ceramic.multiQuery(keys.map(idToString).map((streamId)=>({
                    streamId
                })), params.multiqueryTimeout);
            return keys.map((key)=>{
                const id = idToString(key);
                const doc = results[id];
                return doc ? doc : new Error(`Failed to load document: ${id}`);
            });
        };
        _classPrivateFieldSet(this, _ceramic, params.ceramic);
        _classPrivateFieldSet(this, _useCache, !!params.cache);
    }
}
