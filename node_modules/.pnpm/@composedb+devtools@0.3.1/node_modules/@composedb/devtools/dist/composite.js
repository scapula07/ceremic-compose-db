function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { Model } from '@ceramicnetwork/stream-model';
import { StreamID } from '@ceramicnetwork/streamid';
import { cloneDeep, merge } from 'lodash-es';
import createObjectHash from 'object-hash';
import { decodeSignedMap, encodeSignedMap } from './formats/json.js';
import { createRuntimeDefinition } from './formats/runtime.js';
import { createAbstractCompositeDefinition } from './schema/compiler.js';
const MODEL_GENESIS_OPTS = {
    anchor: true,
    publish: true,
    pin: true
};
function isSignedCommit(input) {
    return Object.keys(input).includes('jws') && Object.keys(input).includes('linkedBlock');
}
function toStrictDefinition(definition) {
    const emptyViews = {
        account: {},
        root: {},
        models: {}
    };
    const views = definition.views ? {
        ...emptyViews,
        ...definition.views
    } : emptyViews;
    return {
        aliases: {},
        commonEmbeds: [],
        ...definition,
        views
    };
}
function isSupportedVersion(supported, check) {
    const [supportedMajor] = supported.split('.');
    const [checkMajor] = check.split('.');
    return supportedMajor === checkMajor;
}
function assertSupportedVersion(supported, check) {
    if (!isSupportedVersion(supported, check)) {
        throw new Error(`Unsupported Composite version ${check}, expected version ${supported}`);
    }
}
function assertModelsHaveCommits(models, commits) {
    for (const id of Object.keys(models)){
        if (commits[id] == null) {
            throw new Error(`Missing commits for model ${id}`);
        }
    }
}
function assertSupportedModelController(model) {
    if (!model.metadata.controller.startsWith('did:key:')) {
        throw new Error(`Unsupported model controller ${model.metadata.controller}, only did:key is supported`);
    }
}
/** @internal */ export function setDefinitionAliases(definition, aliases, replace = false) {
    const existing = replace ? {} : definition.aliases;
    definition.aliases = {
        ...existing,
        ...aliases
    };
    return definition;
}
/** @internal */ export function setDefinitionCommonEmbeds(definition, names, replace = false) {
    const existing = replace ? [] : definition.commonEmbeds;
    definition.commonEmbeds = Array.from(new Set([
        ...existing,
        ...names
    ]));
    return definition;
}
/** @internal */ export function setDefinitionViews(definition, views, replace = false) {
    const existing = replace ? {} : definition.views;
    definition.views = merge(existing, views);
    return definition;
}
async function loadModelsFromCommits(ceramic, modelsCommits // eslint-disable-line @typescript-eslint/ban-types
) {
    const definitions = await Promise.all(Object.values(modelsCommits).map(async (commits)=>{
        const [genesis, ...updates] = commits;
        const model = await ceramic.createStreamFromGenesis(Model.STREAM_TYPE_ID, genesis, MODEL_GENESIS_OPTS);
        assertSupportedModelController(model);
        for (const commit of updates){
            await ceramic.applyCommit(model.id, commit);
        }
        return model;
    }));
    return Object.keys(modelsCommits).reduce((acc, id, index)=>{
        const model = definitions[index];
        if (model == null) {
            throw new Error(`Missing Model for ID ${id}`);
        }
        const modelID = model.id.toString();
        if (modelID !== id) {
            throw new Error(`Unexpected Model stream ID: expected ${id}, got ${modelID}`);
        }
        acc[modelID] = model.content;
        return acc;
    }, {});
}
var _commits = /*#__PURE__*/ new WeakMap(), _definition = /*#__PURE__*/ new WeakMap(), _hash = /*#__PURE__*/ new WeakMap();
/**
 * The Composite class provides APIs for managing composites (sets of Model streams) through their
 * development lifecycle, including the creation of new Models, import and export of existing
 * composites encoded as JSON, and compilation to the runtime format used by the
 * {@linkcode client.ComposeClient ComposeClient class}.
 *
 * Composite instances are **immutable**, so methods affecting the contents of the internal
 * composite definition will **return new instances** of the Composite class.
 *
 * Composite class is exported by the {@linkcode devtools} module.
 *
 * ```sh
 * import { Composite } from '@composedb/devtools'
 * ```
 */ export class Composite {
    /**
   * Create new model streams based on the provided `schema` and group them in a composite
   * wrapped in a Composite instance.
   */ static async create(params) {
        const { commonEmbeds , models  } = createAbstractCompositeDefinition(params.schema);
        const definition = {
            version: Composite.VERSION,
            models: {},
            commonEmbeds
        };
        const modelsViews = {};
        const commits = {};
        // TODO: once interfaces are supported, they need to be loaded or created first
        await Promise.all(// For each model definition...
        Object.values(models).map(async (abstractModel)=>{
            // Create or load the model stream
            let model;
            if (abstractModel.action === 'create') {
                model = await Model.create(params.ceramic, abstractModel.model);
            } else {
                model = await Model.load(params.ceramic, abstractModel.id);
                modelsViews[abstractModel.id] = abstractModel.views;
            }
            assertSupportedModelController(model);
            const id = model.id.toString();
            definition.models[id] = model.content;
            // load stream commits for the model stream
            const streamCommits = await params.ceramic.loadStreamCommits(id);
            commits[id] = streamCommits.map((c)=>c.value).filter(isSignedCommit);
        }));
        definition.views = {
            models: modelsViews
        };
        const composite = new Composite({
            commits,
            definition
        });
        // By default, add models to the index
        if (params.index !== false) {
            await composite.startIndexingOn(params.ceramic);
        }
        return composite;
    }
    /**
   * Create a Composite instance by merging existing composites.
   */ static from(composites, options) {
        const [first, ...rest] = composites;
        if (first == null) {
            throw new Error('Missing composites to compose');
        }
        const composite = first instanceof Composite ? first : new Composite(first);
        return composite.merge(rest, options);
    }
    /**
   * Create a Composite instance from a JSON-encoded `CompositeDefinition`.
   */ static async fromJSON(params) {
        const { models , ...definition } = params.definition;
        const commits = decodeSignedMap(models);
        const composite = new Composite({
            commits,
            definition: {
                ...definition,
                models: await loadModelsFromCommits(params.ceramic, commits)
            }
        });
        // Only add models to the index if explicitly requested
        if (params.index) {
            await composite.startIndexingOn(params.ceramic);
        }
        return composite;
    }
    /**
   * Create a Composite instance from a set of Model streams already present on a Ceramic node.
   */ static async fromModels(params) {
        const definition = {
            version: Composite.VERSION,
            models: {}
        };
        const commits = {};
        await Promise.all(params.models.map(async (id)=>{
            const [model, streamCommits] = await Promise.all([
                Model.load(params.ceramic, id),
                params.ceramic.loadStreamCommits(id)
            ]);
            assertSupportedModelController(model);
            definition.models[id] = model.content;
            commits[id] = streamCommits.map((c)=>c.value).filter(isSignedCommit);
        }));
        const composite = new Composite({
            commits,
            definition
        });
        // Only add models to the index if explicitly requested
        if (params.index) {
            await composite.startIndexingOn(params.ceramic);
        }
        return composite;
    }
    /**
   * Stable hash of the internal definition, mostly used for comparisons.
   */ get hash() {
        if (_classPrivateFieldGet(this, _hash) == null) {
            _classPrivateFieldSet(this, _hash, createObjectHash(_classPrivateFieldGet(this, _definition)));
        }
        return _classPrivateFieldGet(this, _hash);
    }
    /**
   * StreamID of the Models used in the Composite.
   */ get modelIDs() {
        return Object.keys(_classPrivateFieldGet(this, _definition).models);
    }
    /**
   * Copy a given set of Models identified by their stream ID, name or alias into a new Composite.
   */ copy(models) {
        if (models.length === 0) {
            throw new Error('Missing models to copy');
        }
        const { commits , definition  } = this.toParams();
        const def = toStrictDefinition(definition);
        const nameIDs = Object.entries(def.models).reduce((acc, [id, model])=>{
            acc[model.name] = id;
            return acc;
        }, {});
        const aliasIDs = Object.entries(def.aliases).reduce((acc, [id, alias])=>{
            acc[alias] = id;
            return acc;
        }, {});
        const nextCommits = {};
        const nextModels = {};
        const nextAliases = {};
        const nextViews = {
            account: {},
            root: {},
            models: {}
        };
        for (const model of models){
            const id = aliasIDs[model] ?? nameIDs[model] ?? model;
            if (def.models[id] == null) {
                throw new Error(`Model not found: ${model}`);
            }
            nextCommits[id] = commits[id];
            nextModels[id] = def.models[id];
            if (def.aliases[id] != null) {
                nextAliases[id] = def.aliases[id];
            }
        // TODO: check relations to other models, ensure there's no missing model in the subset
        // if (def.views.models[id] != null) {
        //   nextViews.models[id] = def.views.models[id]
        // }
        // TODO: account and root views
        }
        return new Composite({
            commits: nextCommits,
            definition: {
                version: def.version,
                commonEmbeds: def.commonEmbeds,
                models: nextModels,
                aliases: nextAliases,
                views: nextViews
            }
        });
    }
    /**
   * Check if the composite is equal to the other one provided as input.
   */ equals(other) {
        const otherHash = other instanceof Composite ? other.hash : createObjectHash(toStrictDefinition(other.definition));
        return this.hash === otherHash;
    }
    /**
   * Merge the composite with the other one(s) into a new Composite.
   */ merge(other, options = {}) {
        const nextParams = this.toParams();
        const nextDefinition = toStrictDefinition(nextParams.definition);
        const collectedEmbeds = new Set();
        for (const composite of Array.isArray(other) ? other : [
            other
        ]){
            const { commits , definition  } = composite instanceof Composite ? composite.toParams() : composite;
            assertSupportedVersion(nextDefinition.version, definition.version);
            assertModelsHaveCommits(definition.models, commits);
            const def = toStrictDefinition(definition);
            Object.assign(nextParams.commits, commits);
            Object.assign(nextDefinition.models, definition.models);
            Object.assign(nextDefinition.aliases, def.aliases);
            merge(nextDefinition.views, def.views);
            for (const name of def.commonEmbeds){
                collectedEmbeds.add(name);
            }
        }
        if (options.aliases != null) {
            setDefinitionAliases(nextDefinition, options.aliases);
        }
        const commonEmbeds = options.commonEmbeds ?? 'none';
        if (commonEmbeds === 'all') {
            setDefinitionCommonEmbeds(nextDefinition, collectedEmbeds);
        } else if (Array.isArray(commonEmbeds)) {
            setDefinitionCommonEmbeds(nextDefinition, commonEmbeds, true);
        }
        if (options.views != null) {
            setDefinitionViews(nextDefinition, options.views);
        }
        return new Composite({
            ...nextParams,
            definition: nextDefinition
        });
    }
    /**
   * Set aliases for the Models in the composite, merging with existing ones unless `replace` is
   * `true`, and return a new Composite.
   */ setAliases(aliases, replace = false) {
        const params = this.toParams();
        const definition = setDefinitionAliases(toStrictDefinition(params.definition), aliases, replace);
        return new Composite({
            ...params,
            definition
        });
    }
    /**
   * Set common embeds for the Models in the composite, merging with existing ones unless `replace`
   * is `true`, and return a new Composite.
   */ setCommonEmbeds(names, replace = false) {
        const params = this.toParams();
        const definition = setDefinitionCommonEmbeds(toStrictDefinition(params.definition), names, replace);
        return new Composite({
            ...params,
            definition
        });
    }
    /**
   * Set views for the Models in the composite, merging with existing ones unless `replace` is
   * `true`, and return a new Composite.
   */ setViews(views, replace = false) {
        const params = this.toParams();
        const definition = setDefinitionViews(toStrictDefinition(params.definition), views, replace);
        return new Composite({
            ...params,
            definition
        });
    }
    /**
   * Configure the Ceramic node to index the models defined in the composite. An authenticated DID
   * set as admin in the Ceramic node configuration must be attached to the Ceramic instance.
   */ async startIndexingOn(ceramic) {
        const modelIDs = Object.keys(_classPrivateFieldGet(this, _definition).models).map(StreamID.fromString);
        await ceramic.admin.startIndexingModels(modelIDs);
    }
    /**
   * Return a JSON-encoded `CompositeDefinition` structure that can be shared and reused.
   */ toJSON() {
        return {
            version: _classPrivateFieldGet(this, _definition).version,
            models: encodeSignedMap(_classPrivateFieldGet(this, _commits)),
            aliases: _classPrivateFieldGet(this, _definition).aliases,
            views: _classPrivateFieldGet(this, _definition).views
        };
    }
    /**
   * Return a deep clone of the internal {@linkcode CompositeParams} for safe external access.
   */ toParams() {
        return {
            commits: cloneDeep(_classPrivateFieldGet(this, _commits)),
            definition: cloneDeep(_classPrivateFieldGet(this, _definition))
        };
    }
    /**
   * Return a `RuntimeCompositeDefinition` to be used at runtime by the
   * {@linkcode client.ComposeClient ComposeClient}.
   */ toRuntime() {
        return createRuntimeDefinition(_classPrivateFieldGet(this, _definition));
    }
    constructor(params){
        _classPrivateFieldInit(this, _commits, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _definition, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _hash, {
            writable: true,
            value: void 0
        });
        assertSupportedVersion(Composite.VERSION, params.definition.version);
        assertModelsHaveCommits(params.definition.models, params.commits);
        _classPrivateFieldSet(this, _commits, cloneDeep(params.commits));
        _classPrivateFieldSet(this, _definition, toStrictDefinition(cloneDeep(params.definition)));
    }
}
/**
   * Current version of the composites format.
   */ Composite.VERSION = '1.0';
